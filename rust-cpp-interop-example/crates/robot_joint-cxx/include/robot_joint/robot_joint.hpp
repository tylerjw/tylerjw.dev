#pragma once

#include <robot_joint-cxx/src/lib.rs.h> // generated by cxx
#include <rust/cxx.h>
#include <Eigen/Geometry>
#include <vector>
#include <cmath>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

namespace robot_joint {

/// Convert rust Vec<double> to Eigen::Isometry3d
/// Expects 16 elements in column-major order
inline Eigen::Isometry3d to_eigen_isometry3d(rust::Vec<double>&& raw_vec) {
    if (raw_vec.size() != 16) {
        // Return identity on invalid input
        return Eigen::Isometry3d::Identity();
    }
    
    Eigen::Isometry3d transform;
    transform.matrix() = Eigen::Map<const Eigen::Matrix4d>(raw_vec.data());
    return transform;
}

/// Convert rust Vec<double> to Eigen::Isometry3d (const reference version)
inline Eigen::Isometry3d to_eigen_isometry3d(const rust::Vec<double>& raw_vec) {
    if (raw_vec.size() != 16) {
        return Eigen::Isometry3d::Identity();
    }
    
    Eigen::Isometry3d transform;
    transform.matrix() = Eigen::Map<const Eigen::Matrix4d>(raw_vec.data());
    return transform;
}

/// Convert rust::Vec<double> to rust::Slice<const double>
inline rust::Slice<const double> to_rust_slice(const rust::Vec<double>& vec) {
    return rust::Slice<const double>(vec.data(), vec.size());
}

/// Convert Eigen::VectorXd to rust::Slice<const double>
inline rust::Slice<const double> to_rust_slice(const Eigen::VectorXd& vec) {
    return rust::Slice<const double>(vec.data(), static_cast<size_t>(vec.size()));
}

/// Convert std::vector<double> to rust::Slice<const double>
inline rust::Slice<const double> to_rust_slice(const std::vector<double>& vec) {
    return rust::Slice<const double>(vec.data(), vec.size());
}

/// Convert Eigen::Isometry3d to rust::Vec<double> (column-major)
inline rust::Vec<double> to_rust_vec(const Eigen::Isometry3d& transform) {
    rust::Vec<double> vec;
    vec.reserve(16);
    
    const auto& matrix = transform.matrix();
    // Store in column-major order
    for (int col = 0; col < 4; ++col) {
        for (int row = 0; row < 4; ++row) {
            vec.push_back(matrix(row, col));
        }
    }
    
    return vec;
}

/// Convert std::vector<Eigen::Isometry3d> to rust::Vec<double>
inline rust::Vec<double> to_rust_vec(const std::vector<Eigen::Isometry3d>& transforms) {
    rust::Vec<double> vec;
    vec.reserve(16 * transforms.size());
    
    for (const auto& transform : transforms) {
        const auto& matrix = transform.matrix();
        for (int col = 0; col < 4; ++col) {
            for (int row = 0; row < 4; ++row) {
                vec.push_back(matrix(row, col));
            }
        }
    }
    
    return vec;
}

/// Convert rust::Vec<double> to std::vector<Eigen::Isometry3d>
/// Expects data in groups of 16 elements (column-major 4x4 matrices)
inline std::vector<Eigen::Isometry3d> to_eigen_isometry_vector(rust::Vec<double>&& raw_vec) {
    constexpr size_t kMatrixSize = 16;
    const size_t num_transforms = raw_vec.size() / kMatrixSize;
    
    std::vector<Eigen::Isometry3d> transforms;
    transforms.reserve(num_transforms);
    
    for (size_t i = 0; i < num_transforms; ++i) {
        const double* matrix_data = raw_vec.data() + (i * kMatrixSize);
        Eigen::Isometry3d transform;
        transform.matrix() = Eigen::Map<const Eigen::Matrix4d>(matrix_data);
        transforms.push_back(transform);
    }
    
    return transforms;
}

/// Convert rust limits Vec<double> to std::pair<double, double>
/// Expects exactly 2 elements [min, max]
inline std::pair<double, double> to_limits_pair(const rust::Vec<double>& limits_vec) {
    if (limits_vec.size() != 2) {
        return {0.0, 0.0};
    }
    return {limits_vec[0], limits_vec[1]};
}

/// Convert rust::String to std::string
inline std::string to_std_string(const rust::String& rust_str) {
    return std::string(rust_str.data(), rust_str.size());
}

/// Convert std::string to rust::String
inline rust::String to_rust_string(const std::string& std_str) {
    return rust::String(std_str);
}

/// Convert std::vector<T> to rust::Vec<T>
template <typename T>
rust::Vec<T> to_rust_vec(const std::vector<T>& cpp_vec) {
    rust::Vec<T> rust_vec;
    rust_vec.reserve(cpp_vec.size());
    for (const auto& item : cpp_vec) {
        rust_vec.push_back(item);
    }
    return rust_vec;
}

/// Convert rust::Vec<T> to std::vector<T>
template <typename T>
std::vector<T> to_std_vector(const rust::Vec<T>& rust_vec) {
    std::vector<T> cpp_vec;
    cpp_vec.reserve(rust_vec.size());
    std::copy(rust_vec.begin(), rust_vec.end(), std::back_inserter(cpp_vec));
    return cpp_vec;
}

} // namespace robot_joint